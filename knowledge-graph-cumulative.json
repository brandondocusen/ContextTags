[{"Module":"FieldAnalyzer","Tags":["FieldElement","FieldDeclaration","analyzeField"],"Content":{"description":"@Component\npublic class FieldAnalyzer {\n    public FieldElement analyzeField(FieldDeclaration fieldDecl) {\n        // Extract code block for field\n        String fieldCodeBlock = fieldDecl.getTokenRange().orElseThrow().toString();\n\n        return fieldDecl.getVariables().stream()\n            .map(var -> {\n                FieldElement fieldElement = new FieldElement(\n                    UUID.randomUUID().toString(),\n                    var.getNameAsString(),\n                    fieldDecl.getElementType().asString()\n                );\n                fieldElement.setCodeBlock(fieldCodeBlock); // Set code block for each field element\n                return fieldElement;\n            })\n            .findFirst()\n            .orElse(null);\n    }\n}","methods":[{"method":"analyzeField","description":"public FieldElement analyzeField(FieldDeclaration fieldDecl) {\n        // Extract code block for field\n        String fieldCodeBlock = fieldDecl.getTokenRange().orElseThrow().toString();\n\n        return fieldDecl.getVariables().stream()\n            .map(var -> {\n                FieldElement fieldElement = new FieldElement(\n                    UUID.randomUUID().toString(),\n                    var.getNameAsString(),\n                    fieldDecl.getElementType().asString()\n                );\n                fieldElement.setCodeBlock(fieldCodeBlock); // Set code block for each field element\n                return fieldElement;\n            })\n            .findFirst()\n            .orElse(null);\n    }"}],"dependencies":["FieldElement","FieldDeclaration"]}},{"Module":"MethodAnalyzer","Tags":["MethodDeclaration","MethodElement","analyzeMethod"],"Content":{"description":"@Component\npublic class MethodAnalyzer {\n    public MethodElement analyzeMethod(MethodDeclaration methodDecl) {\n        String methodName = methodDecl.getNameAsString();\n        MethodElement methodElement = new MethodElement(\n            UUID.randomUUID().toString(),\n            methodName\n        );\n\n        // Extract code block for method\n        String methodCodeBlock = methodDecl.getTokenRange().orElseThrow().toString();\n        methodElement.setCodeBlock(methodCodeBlock);\n\n        // Analyze parameters\n        methodDecl.getParameters().forEach(param -> \n            methodElement.addParameter(param.getTypeAsString(), param.getNameAsString()));\n\n        // Analyze return type\n        methodElement.setReturnType(methodDecl.getTypeAsString());\n\n        return methodElement;\n    }\n}","methods":[{"method":"analyzeMethod","description":"public MethodElement analyzeMethod(MethodDeclaration methodDecl) {\n        String methodName = methodDecl.getNameAsString();\n        MethodElement methodElement = new MethodElement(\n            UUID.randomUUID().toString(),\n            methodName\n        );\n\n        // Extract code block for method\n        String methodCodeBlock = methodDecl.getTokenRange().orElseThrow().toString();\n        methodElement.setCodeBlock(methodCodeBlock);\n\n        // Analyze parameters\n        methodDecl.getParameters().forEach(param -> \n            methodElement.addParameter(param.getTypeAsString(), param.getNameAsString()));\n\n        // Analyze return type\n        methodElement.setReturnType(methodDecl.getTypeAsString());\n\n        return methodElement;\n    }"}],"dependencies":["MethodDeclaration","MethodElement"]}},{"Module":"ModuleAnalyzer","Tags":["Path","Pattern","ModuleInfo","Logger","File","List<ModuleInfo>","analyzeModule","analyzeProjectModules"],"Content":{"description":"@Component\npublic class ModuleAnalyzer {\n    private static final Logger logger = LoggerFactory.getLogger(ModuleAnalyzer.class);\n    \n    private static final Pattern MODULE_PATTERN = Pattern.compile(\n        \"module\\\\s+(\\\\w+)\\\\s*\\\\{([^}]+)\\\\}\"\n    );\n    \n    private static final Pattern EXPORTS_PATTERN = Pattern.compile(\n        \"exports\\\\s+([\\\\w.]+)\\\\s*;\"\n    );\n    \n    private static final Pattern REQUIRES_PATTERN = Pattern.compile(\n        \"requires\\\\s+([\\\\w.]+)\\\\s*;\"\n    );\n\n    public ModuleInfo analyzeModule(File moduleInfoFile) throws IOException {\n        logger.debug(\"Analyzing module file: {}\", moduleInfoFile.getPath());\n        \n        if (!moduleInfoFile.getName().equals(\"module-info.java\")) {\n            logger.debug(\"File is not a module-info.java file: {}\", moduleInfoFile.getName());\n            return null;\n        }\n\n        String content = Files.readString(moduleInfoFile.toPath());\n        Matcher moduleMatcher = MODULE_PATTERN.matcher(content);\n        \n        if (!moduleMatcher.find()) {\n            logger.debug(\"No module declaration found in file\");\n            return null;\n        }\n\n        String moduleName = moduleMatcher.group(1);\n        String moduleBody = moduleMatcher.group(2);\n        \n        ModuleInfo moduleInfo = new ModuleInfo(moduleName, \"1.0\");\n        logger.info(\"Found module: {}\", moduleName);\n        \n        // Extract exports\n        Matcher exportsMatcher = EXPORTS_PATTERN.matcher(moduleBody);\n        while (exportsMatcher.find()) {\n            String export = exportsMatcher.group(1);\n            moduleInfo.addExport(export);\n            logger.debug(\"Found export: {}\", export);\n        }\n        \n        // Extract requires\n        Matcher requiresMatcher = REQUIRES_PATTERN.matcher(moduleBody);\n        while (requiresMatcher.find()) {\n            String requirement = requiresMatcher.group(1);\n            moduleInfo.addRequirement(requirement);\n            logger.debug(\"Found requirement: {}\", requirement);\n        }\n        \n        return moduleInfo;\n    }\n\n    public List<ModuleInfo> analyzeProjectModules(Path projectRoot) throws IOException {\n        logger.info(\"Analyzing project modules at: {}\", projectRoot);\n        List<ModuleInfo> modules = new ArrayList<>();\n        \n        Files.walk(projectRoot)\n            .filter(path -> path.getFileName().toString().equals(\"module-info.java\"))\n            .forEach(path -> {\n                try {\n                    ModuleInfo info = analyzeModule(path.toFile());\n                    if (info != null) {\n                        modules.add(info);\n                        logger.info(\"Added module info for: {}\", info.getName());\n                    }\n                } catch (IOException e) {\n                    logger.error(\"Error analyzing module file: {}\", path, e);\n                }\n            });\n            \n        return modules;\n    }\n}","methods":[{"method":"analyzeModule","description":"public ModuleInfo analyzeModule(File moduleInfoFile) throws IOException {\n        logger.debug(\"Analyzing module file: {}\", moduleInfoFile.getPath());\n        \n        if (!moduleInfoFile.getName().equals(\"module-info.java\")) {\n            logger.debug(\"File is not a module-info.java file: {}\", moduleInfoFile.getName());\n            return null;\n        }\n\n        String content = Files.readString(moduleInfoFile.toPath());\n        Matcher moduleMatcher = MODULE_PATTERN.matcher(content);\n        \n        if (!moduleMatcher.find()) {\n            logger.debug(\"No module declaration found in file\");\n            return null;\n        }\n\n        String moduleName = moduleMatcher.group(1);\n        String moduleBody = moduleMatcher.group(2);\n        \n        ModuleInfo moduleInfo = new ModuleInfo(moduleName, \"1.0\");\n        logger.info(\"Found module: {}\", moduleName);\n        \n        // Extract exports\n        Matcher exportsMatcher = EXPORTS_PATTERN.matcher(moduleBody);\n        while (exportsMatcher.find()) {\n            String export = exportsMatcher.group(1);\n            moduleInfo.addExport(export);\n            logger.debug(\"Found export: {}\", export);\n        }\n        \n        // Extract requires\n        Matcher requiresMatcher = REQUIRES_PATTERN.matcher(moduleBody);\n        while (requiresMatcher.find()) {\n            String requirement = requiresMatcher.group(1);\n            moduleInfo.addRequirement(requirement);\n            logger.debug(\"Found requirement: {}\", requirement);\n        }\n        \n        return moduleInfo;\n    }"},{"method":"analyzeProjectModules","description":"public List<ModuleInfo> analyzeProjectModules(Path projectRoot) throws IOException {\n        logger.info(\"Analyzing project modules at: {}\", projectRoot);\n        List<ModuleInfo> modules = new ArrayList<>();\n        \n        Files.walk(projectRoot)\n            .filter(path -> path.getFileName().toString().equals(\"module-info.java\"))\n            .forEach(path -> {\n                try {\n                    ModuleInfo info = analyzeModule(path.toFile());\n                    if (info != null) {\n                        modules.add(info);\n                        logger.info(\"Added module info for: {}\", info.getName());\n                    }\n                } catch (IOException e) {\n                    logger.error(\"Error analyzing module file: {}\", path, e);\n                }\n            });\n            \n        return modules;\n    }"}],"dependencies":["Path","Pattern","ModuleInfo","Logger","File","List<ModuleInfo>"]}},{"Module":"RuntimeAnalyzer","Tags":["Map<String,Set<String>>","void","String","Logger","int","JoinPoint","applicationCode","beforeMethodCall","getMethodCalls","debugAllMethodCalls","getTotalMethodCallCount","clearRecordedCalls"],"Content":{"description":"@Aspect\n@Component\npublic class RuntimeAnalyzer {\n    private static final Logger logger = LoggerFactory.getLogger(RuntimeAnalyzer.class);\n    private final Map<String, Set<String>> methodCalls = new ConcurrentHashMap<>();\n\n    // Pointcut to exclude RuntimeAnalyzer's own methods\n    @Pointcut(\"execution(* com..*.*(..)) && !within(com.discovery.analyzer.RuntimeAnalyzer)\")\n    public void applicationCode() {}\n\n    /**\n     * Intercepts all method calls within classes under the `com..*` package,\n     * excluding the RuntimeAnalyzer itself.\n     *\n     * @param joinPoint provides context about the intercepted method call\n     */\n    @Before(\"applicationCode()\")\n    public void beforeMethodCall(JoinPoint joinPoint) {\n        try {\n            String callerClass = joinPoint.getSignature().getDeclaringTypeName();\n            String callerMethod = joinPoint.getSignature().getName();\n            String caller = callerClass + \"#\" + callerMethod;\n\n            // Log intercepted method for debugging\n            logger.debug(\"Intercepted method call: {}\", caller);\n\n            // Pre-create the set if necessary to avoid recursive computeIfAbsent\n            methodCalls.putIfAbsent(callerClass, ConcurrentHashMap.newKeySet());\n            methodCalls.get(callerClass).add(caller);\n            \n        } catch (Exception e) {\n            logger.error(\"Error in method interception\", e);\n        }\n    }\n\n    /**\n     * Retrieves the intercepted method calls for a specific class.\n     *\n     * @param className the name of the class to retrieve method calls for\n     * @return a map containing method calls for the given class\n     */\n    public Map<String, Set<String>> getMethodCalls(String className) {\n        logger.debug(\"Querying RuntimeAnalyzer for class: {}\", className);\n        logger.debug(\"Current methodCalls map: {}\", methodCalls);\n\n        Map<String, Set<String>> results = new HashMap<>();\n        results.put(\"methodCalls\", methodCalls.getOrDefault(className, Collections.emptySet()));\n        return results;\n    }\n\n    /**\n     * Debugging utility to print all intercepted calls for all classes.\n     *\n     * @return a string representation of all intercepted calls\n     */\n    public String debugAllMethodCalls() {\n        StringBuilder debugInfo = new StringBuilder(\"All intercepted method calls:\\n\");\n        methodCalls.forEach((className, methods) -> {\n            debugInfo.append(\"Class: \").append(className).append(\"\\n\");\n            methods.forEach(method -> debugInfo.append(\"  Method: \").append(method).append(\"\\n\"));\n        });\n        return debugInfo.toString();\n    }\n\n    /**\n     * Gets the total number of unique method calls intercepted.\n     *\n     * @return the total count of unique method calls\n     */\n    public int getTotalMethodCallCount() {\n        return methodCalls.values().stream()\n                .mapToInt(Set::size)\n                .sum();\n    }\n\n    /**\n     * Clears all recorded method calls.\n     * Useful for testing or when needing to reset the analyzer state.\n     */\n    public void clearRecordedCalls() {\n        methodCalls.clear();\n        logger.info(\"Cleared all recorded method calls\");\n    }\n}","methods":[{"method":"applicationCode","description":"@Pointcut(\"execution(* com..*.*(..)) && !within(com.discovery.analyzer.RuntimeAnalyzer)\")\n    public void applicationCode() {}"},{"method":"beforeMethodCall","description":"@Before(\"applicationCode()\")\n    public void beforeMethodCall(JoinPoint joinPoint) {\n        try {\n            String callerClass = joinPoint.getSignature().getDeclaringTypeName();\n            String callerMethod = joinPoint.getSignature().getName();\n            String caller = callerClass + \"#\" + callerMethod;\n\n            // Log intercepted method for debugging\n            logger.debug(\"Intercepted method call: {}\", caller);\n\n            // Pre-create the set if necessary to avoid recursive computeIfAbsent\n            methodCalls.putIfAbsent(callerClass, ConcurrentHashMap.newKeySet());\n            methodCalls.get(callerClass).add(caller);\n            \n        } catch (Exception e) {\n            logger.error(\"Error in method interception\", e);\n        }\n    }"},{"method":"getMethodCalls","description":"public Map<String, Set<String>> getMethodCalls(String className) {\n        logger.debug(\"Querying RuntimeAnalyzer for class: {}\", className);\n        logger.debug(\"Current methodCalls map: {}\", methodCalls);\n\n        Map<String, Set<String>> results = new HashMap<>();\n        results.put(\"methodCalls\", methodCalls.getOrDefault(className, Collections.emptySet()));\n        return results;\n    }"},{"method":"debugAllMethodCalls","description":"public String debugAllMethodCalls() {\n        StringBuilder debugInfo = new StringBuilder(\"All intercepted method calls:\\n\");\n        methodCalls.forEach((className, methods) -> {\n            debugInfo.append(\"Class: \").append(className).append(\"\\n\");\n            methods.forEach(method -> debugInfo.append(\"  Method: \").append(method).append(\"\\n\"));\n        });\n        return debugInfo.toString();\n    }"},{"method":"getTotalMethodCallCount","description":"public int getTotalMethodCallCount() {\n        return methodCalls.values().stream()\n                .mapToInt(Set::size)\n                .sum();\n    }"},{"method":"clearRecordedCalls","description":"public void clearRecordedCalls() {\n        methodCalls.clear();\n        logger.info(\"Cleared all recorded method calls\");\n    }"}],"dependencies":["Map<String,Set<String>>","void","String","Logger","int","JoinPoint"]}},{"Module":"VariableAnalyzer","Tags":["List<VariableDeclarator>","Map<String,Set<String>>","Map<String,Object>","List<Map<String,Object>>","VariableDeclarator","AssignExpr","analyzeVariable","analyzeAssignments","buildVariableDependencyGraph"],"Content":{"description":"@Component\npublic class VariableAnalyzer {\n    public Map<String, Object> analyzeVariable(VariableDeclarator variable) {\n        Map<String, Object> varInfo = new HashMap<>();\n        \n        varInfo.put(\"name\", variable.getNameAsString());\n        varInfo.put(\"type\", variable.getType().toString());\n        \n        // Check for initialization\n        variable.getInitializer().ifPresent(init -> \n            varInfo.put(\"initialValue\", init.toString()));\n        \n        // Get modifiers if available\n        variable.getParentNode().ifPresent(parent -> \n            varInfo.put(\"modifiers\", parent.toString()));\n            \n        return varInfo;\n    }\n    \n    public List<Map<String, Object>> analyzeAssignments(AssignExpr assign) {\n        List<Map<String, Object>> assignments = new ArrayList<>();\n        Map<String, Object> assignInfo = new HashMap<>();\n        \n        assignInfo.put(\"target\", assign.getTarget().toString());\n        assignInfo.put(\"value\", assign.getValue().toString());\n        assignInfo.put(\"operator\", assign.getOperator().toString());\n        \n        assignments.add(assignInfo);\n        return assignments;\n    }\n    \n    public Map<String, Set<String>> buildVariableDependencyGraph(List<VariableDeclarator> variables) {\n        Map<String, Set<String>> dependencies = new HashMap<>();\n        \n        variables.forEach(var -> {\n            String varName = var.getNameAsString();\n            dependencies.putIfAbsent(varName, new HashSet<>());\n            \n            var.getInitializer().ifPresent(init -> {\n                init.findAll(com.github.javaparser.ast.expr.NameExpr.class)\n                    .forEach(name -> {\n                        dependencies.get(varName).add(name.getNameAsString());\n                    });\n            });\n        });\n        \n        return dependencies;\n    }\n}","methods":[{"method":"analyzeVariable","description":"public Map<String, Object> analyzeVariable(VariableDeclarator variable) {\n        Map<String, Object> varInfo = new HashMap<>();\n        \n        varInfo.put(\"name\", variable.getNameAsString());\n        varInfo.put(\"type\", variable.getType().toString());\n        \n        // Check for initialization\n        variable.getInitializer().ifPresent(init -> \n            varInfo.put(\"initialValue\", init.toString()));\n        \n        // Get modifiers if available\n        variable.getParentNode().ifPresent(parent -> \n            varInfo.put(\"modifiers\", parent.toString()));\n            \n        return varInfo;\n    }"},{"method":"analyzeAssignments","description":"public List<Map<String, Object>> analyzeAssignments(AssignExpr assign) {\n        List<Map<String, Object>> assignments = new ArrayList<>();\n        Map<String, Object> assignInfo = new HashMap<>();\n        \n        assignInfo.put(\"target\", assign.getTarget().toString());\n        assignInfo.put(\"value\", assign.getValue().toString());\n        assignInfo.put(\"operator\", assign.getOperator().toString());\n        \n        assignments.add(assignInfo);\n        return assignments;\n    }"},{"method":"buildVariableDependencyGraph","description":"public Map<String, Set<String>> buildVariableDependencyGraph(List<VariableDeclarator> variables) {\n        Map<String, Set<String>> dependencies = new HashMap<>();\n        \n        variables.forEach(var -> {\n            String varName = var.getNameAsString();\n            dependencies.putIfAbsent(varName, new HashSet<>());\n            \n            var.getInitializer().ifPresent(init -> {\n                init.findAll(com.github.javaparser.ast.expr.NameExpr.class)\n                    .forEach(name -> {\n                        dependencies.get(varName).add(name.getNameAsString());\n                    });\n            });\n        });\n        \n        return dependencies;\n    }"}],"dependencies":["List<VariableDeclarator>","Map<String,Set<String>>","Map<String,Object>","List<Map<String,Object>>","VariableDeclarator","AssignExpr"]}},{"Module":"CodeDiscoveryApplication","Tags":["void","String[]"],"Content":{"description":"@SpringBootApplication\npublic class CodeDiscoveryApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(CodeDiscoveryApplication.class, args);\n    }\n}","methods":[{"method":"main","description":"public static void main(String[] args) {\n        SpringApplication.run(CodeDiscoveryApplication.class, args);\n    }"}],"dependencies":["void","String[]"]}},{"Module":"KafkaConfig","Tags":["KafkaTemplate<String,String>","ConcurrentKafkaListenerContainerFactory<String,String>","String","ConsumerFactory<String,String>","ProducerFactory<String,String>"],"Content":{"description":"@Configuration\npublic class KafkaConfig {\n    @Value(\"${spring.kafka.bootstrap-servers}\")\n    private String bootstrapServers;\n\n    @Bean\n    public ProducerFactory<String, String> producerFactory() {\n        Map<String, Object> configs = new HashMap<>();\n        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        return new DefaultKafkaProducerFactory<>(configs);\n    }\n\n    @Bean\n    public ConsumerFactory<String, String> consumerFactory() {\n        Map<String, Object> configs = new HashMap<>();\n        configs.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        configs.put(ConsumerConfig.GROUP_ID_CONFIG, \"code-discovery-group\");\n        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);\n        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);\n        return new DefaultKafkaConsumerFactory<>(configs);\n    }\n\n    @Bean\n    public KafkaTemplate<String, String> kafkaTemplate() {\n        return new KafkaTemplate<>(producerFactory());\n    }\n\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory() {\n        ConcurrentKafkaListenerContainerFactory<String, String> factory = new ConcurrentKafkaListenerContainerFactory<>();\n        factory.setConsumerFactory(consumerFactory());\n        return factory;\n    }\n}","methods":[{"method":"producerFactory","description":"@Bean\n    public ProducerFactory<String, String> producerFactory() {\n        Map<String, Object> configs = new HashMap<>();\n        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        return new DefaultKafkaProducerFactory<>(configs);\n    }"},{"method":"consumerFactory","description":"@Bean\n    public ConsumerFactory<String, String> consumerFactory() {\n        Map<String, Object> configs = new HashMap<>();\n        configs.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        configs.put(ConsumerConfig.GROUP_ID_CONFIG, \"code-discovery-group\");\n        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);\n        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);\n        return new DefaultKafkaConsumerFactory<>(configs);\n    }"},{"method":"kafkaTemplate","description":"@Bean\n    public KafkaTemplate<String, String> kafkaTemplate() {\n        return new KafkaTemplate<>(producerFactory());\n    }"},{"method":"kafkaListenerContainerFactory","description":"@Bean\n    public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory() {\n        ConcurrentKafkaListenerContainerFactory<String, String> factory = new ConcurrentKafkaListenerContainerFactory<>();\n        factory.setConsumerFactory(consumerFactory());\n        return factory;\n    }"}],"dependencies":["KafkaTemplate<String,String>","ConcurrentKafkaListenerContainerFactory<String,String>","String","ConsumerFactory<String,String>","ProducerFactory<String,String>"]}},{"Module":"RepositoryConfig","Tags":["CodeElementRepository"],"Content":{"description":"@Configuration\r\npublic class RepositoryConfig {\r\n\r\n    @Bean\r\n    public CodeElementRepository codeElementRepository() {\r\n        return new InMemoryCodeElementRepository();\r\n    }\r\n}","methods":[{"method":"codeElementRepository","description":"@Bean\r\n    public CodeElementRepository codeElementRepository() {\r\n        return new InMemoryCodeElementRepository();\r\n    }"}],"dependencies":["CodeElementRepository"]}},{"Module":"CodeAnalysisController","Tags":["CodeAnalyzer","Map<String,Object>","String","Logger"],"Content":{"description":"@RestController\n@RequestMapping(\"/analyze\")\npublic class CodeAnalysisController {\n    private static final Logger logger = LoggerFactory.getLogger(CodeAnalysisController.class);\n    private final CodeAnalyzer codeAnalyzer;\n\n    public CodeAnalysisController(CodeAnalyzer codeAnalyzer) {\n        this.codeAnalyzer = codeAnalyzer;\n    }\n\n    @GetMapping(\"/scan\")\n    public Map<String, Object> analyzePath(@RequestParam(name = \"path\", required = true) String path) {\n        try {\n            // Decode the URL-encoded path\n            String decodedPath = URLDecoder.decode(path, StandardCharsets.UTF_8)\n                .replace(\"\\\\\", \"/\"); // Normalize path separators\n    \n            logger.info(\"Starting analysis of path: {}\", decodedPath);\n            \n            File dir = new File(decodedPath);\n            if (!dir.exists()) {\n                logger.error(\"Path does not exist: {}\", decodedPath);\n                return Map.of(\n                    \"status\", \"error\",\n                    \"message\", \"Path does not exist: \" + decodedPath\n                );\n            }\n    \n            Map<String, Object> results = codeAnalyzer.analyzePath(decodedPath);\n            logger.info(\"Analysis complete for path: {}. Found {} files\", \n                       decodedPath, results.getOrDefault(\"totalFiles\", 0));\n            return results;\n        } catch (Exception e) {\n            logger.error(\"Error analyzing path: {}\", path, e);\n            return Map.of(\n                \"status\", \"error\",\n                \"message\", \"Error analyzing path: \" + e.getMessage()\n            );\n        }\n    }\n\n    @GetMapping(\"/relationships/{className}\")\n    public Map<String, Object> getRelationships(@PathVariable String className) {\n        try {\n            logger.info(\"Getting relationships for class: {}\", className);\n            Map<String, Object> relationships = codeAnalyzer.getDynamicRelationships(className);\n            \n            // Add additional status information\n            relationships.put(\"status\", \"success\");\n            relationships.put(\"className\", className);\n            \n            // Safe type checking for static analysis results\n            Object staticAnalysis = relationships.get(\"staticAnalysis\");\n            if (staticAnalysis == null || \n                (staticAnalysis instanceof List && ((List<?>) staticAnalysis).isEmpty())) {\n                logger.warn(\"No static analysis results found for class: {}\", className);\n                relationships.put(\"staticAnalysis\", Collections.emptyList());\n            }\n            \n            return relationships;\n        } catch (Exception e) {\n            logger.error(\"Error getting relationships for class: {}\", className, e);\n            return Map.of(\n                \"status\", \"error\",\n                \"message\", \"Error getting relationships: \" + e.getMessage()\n            );\n        }\n    }\n}","methods":[{"method":"analyzePath","description":"@GetMapping(\"/scan\")\n    public Map<String, Object> analyzePath(@RequestParam(name = \"path\", required = true) String path) {\n        try {\n            // Decode the URL-encoded path\n            String decodedPath = URLDecoder.decode(path, StandardCharsets.UTF_8)\n                .replace(\"\\\\\", \"/\"); // Normalize path separators\n    \n            logger.info(\"Starting analysis of path: {}\", decodedPath);\n            \n            File dir = new File(decodedPath);\n            if (!dir.exists()) {\n                logger.error(\"Path does not exist: {}\", decodedPath);\n                return Map.of(\n                    \"status\", \"error\",\n                    \"message\", \"Path does not exist: \" + decodedPath\n                );\n            }\n    \n            Map<String, Object> results = codeAnalyzer.analyzePath(decodedPath);\n            logger.info(\"Analysis complete for path: {}. Found {} files\", \n                       decodedPath, results.getOrDefault(\"totalFiles\", 0));\n            return results;\n        } catch (Exception e) {\n            logger.error(\"Error analyzing path: {}\", path, e);\n            return Map.of(\n                \"status\", \"error\",\n                \"message\", \"Error analyzing path: \" + e.getMessage()\n            );\n        }\n    }"},{"method":"getRelationships","description":"@GetMapping(\"/relationships/{className}\")\n    public Map<String, Object> getRelationships(@PathVariable String className) {\n        try {\n            logger.info(\"Getting relationships for class: {}\", className);\n            Map<String, Object> relationships = codeAnalyzer.getDynamicRelationships(className);\n            \n            // Add additional status information\n            relationships.put(\"status\", \"success\");\n            relationships.put(\"className\", className);\n            \n            // Safe type checking for static analysis results\n            Object staticAnalysis = relationships.get(\"staticAnalysis\");\n            if (staticAnalysis == null || \n                (staticAnalysis instanceof List && ((List<?>) staticAnalysis).isEmpty())) {\n                logger.warn(\"No static analysis results found for class: {}\", className);\n                relationships.put(\"staticAnalysis\", Collections.emptyList());\n            }\n            \n            return relationships;\n        } catch (Exception e) {\n            logger.error(\"Error getting relationships for class: {}\", className, e);\n            return Map.of(\n                \"status\", \"error\",\n                \"message\", \"Error getting relationships: \" + e.getMessage()\n            );\n        }\n    }"}],"dependencies":["CodeAnalyzer","Map<String,Object>","String","Logger"]}},{"Module":"CodeDiscoveryController","Tags":["Map<String,Object>","CodeDiscoveryService","String"],"Content":{"description":"@RestController\npublic class CodeDiscoveryController {\n    private final CodeDiscoveryService discoveryService;\n\n    public CodeDiscoveryController(CodeDiscoveryService discoveryService) {\n        this.discoveryService = discoveryService;\n    }\n\n    @GetMapping(\"/test\")\n    public Map<String, Object> testQuery(@RequestParam String query) {\n        return discoveryService.processQuery(query);\n    }\n}","methods":[{"method":"testQuery","description":"@GetMapping(\"/test\")\n    public Map<String, Object> testQuery(@RequestParam String query) {\n        return discoveryService.processQuery(query);\n    }"}],"dependencies":["Map<String,Object>","CodeDiscoveryService","String"]}},{"Module":"DataFlowController","Tags":["Map<String,Object>","DataFlowAnalyzer","String","Logger","analyzeDataFlow"],"Content":{"description":"@RestController\r\n@RequestMapping(\"/analyze\")\r\npublic class DataFlowController { ... }","methods":[{"method":"analyzeDataFlow","description":"@GetMapping(\"/data-flow\")\r\n    public Map<String, Object> analyzeDataFlow(\r\n            @RequestParam String className,\r\n            @RequestParam String method) { ... }"}],"dependencies":["Map<String,Object>","DataFlowAnalyzer","String","Logger"]}},{"Module":"DataManagementController","Tags":["void","Map<String,String>","CodeElementRepository","String","CodeElement","loadSampleData","addElement","addDependency"],"Content":{"description":"@RestController\n@RequestMapping(\"/data\")\npublic class DataManagementController { ... }","methods":[{"method":"loadSampleData","description":"private void loadSampleData() { ... }"},{"method":"addElement","description":"@PostMapping(\"/add\")\n    public CodeElement addElement(@RequestBody Map<String, String> request) { ... }"},{"method":"addDependency","description":"@PostMapping(\"/addDependency\")\n    public void addDependency(\n            @RequestParam String elementId,\n            @RequestParam String dependencyId) { ... }"}],"dependencies":["void","Map<String,String>","CodeElementRepository","String","CodeElement"]}},{"Module":"LauncherController","Tags":["ResponseEntity<?>","CodebaseAnalysisLauncher","String","Logger","AnalysisService","ResponseEntity<String>","analyzeFull","healthCheck"],"Content":{"description":"@RestController\r\n@RequestMapping(\"/analyze\")\r\npublic class LauncherController { ... }","methods":[{"method":"analyzeFull","description":"@GetMapping(value = \"/full\", produces = \"application/json\")\r\n    public ResponseEntity<?> analyzeFull(\r\n            @RequestParam(value = \"path\", required = true) String path) { ... }"},{"method":"healthCheck","description":"@GetMapping(\"/health\")\r\n    public ResponseEntity<String> healthCheck() { ... }"}],"dependencies":["ResponseEntity<?>","CodebaseAnalysisLauncher","String","Logger","AnalysisService","ResponseEntity<String>"]}},{"Module":"StateController","Tags":["StateMachine","Map<String,Object>","String","Logger","getStates","checkTransition"],"Content":{"description":"@RestController\r\n@RequestMapping(\"/analyze\")\r\npublic class StateController { ... }","methods":[{"method":"getStates","description":"@GetMapping(\"/states/{className}\")\r\n    public Map<String, Object> getStates(@PathVariable String className) { ... }"},{"method":"checkTransition","description":"@GetMapping(\"/state-transitions\")\r\n    public Map<String, Object> checkTransition(\r\n            @RequestParam String className,\r\n            @RequestParam String from,\r\n            @RequestParam String to) { ... }"}],"dependencies":["StateMachine","Map<String,Object>","String","Logger"]}},{"Module":"WebConfig","Tags":["void","WebMvcConfigurer","List<HandlerMethodArgumentResolver>","addArgumentResolvers"],"Content":{"description":"@Configuration\r\npublic class WebConfig implements WebMvcConfigurer { ... }","methods":[{"method":"addArgumentResolvers","description":"@Override\r\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) { ... }"}],"dependencies":["void","WebMvcConfigurer","List<HandlerMethodArgumentResolver>"]}},{"Module":"CodeEvent","Tags":["CodeEvent","addData","getId","getType","getSource","getTimestamp","getData","getPriority","setPriority","void","Instant","Map<String,Object>","Object","String","EventPriority"],"Content":{"description":"Represents a code event with an ID, type, source, timestamp, data, and priority.  It provides methods to add data to the event and retrieve its properties.","methods":[{"method":"addData","description":"Adds a key-value pair to the event's data map."},{"method":"getId","description":"Returns the unique ID of the code event."},{"method":"getType","description":"Returns the type of the code event."},{"method":"getSource","description":"Returns the source of the code event."},{"method":"getTimestamp","description":"Returns the timestamp of when the event occurred."},{"method":"getData","description":"Returns the data map associated with the code event."},{"method":"getPriority","description":"Returns the priority of the code event."},{"method":"setPriority","description":"Sets the priority of the code event."}],"dependencies":["void","Instant","Map<String,Object>","Object","String","EventPriority"]}},{"Module":"EventBus","Tags":["EventBus","subscribe","publish","void","ExecutorService","CodeEvent","String","EventListener","Map<String,Set<EventListener>>"],"Content":{"description":"Manages the subscription and publication of CodeEvents.  Listeners can subscribe to specific event types, and the EventBus publishes events to subscribed listeners asynchronously using an ExecutorService.","methods":[{"method":"subscribe","description":"Subscribes an EventListener to a specific event type."},{"method":"publish","description":"Publishes a CodeEvent to all subscribed listeners for the event's type."}],"dependencies":["void","ExecutorService","CodeEvent","String","EventListener","Map<String,Set<EventListener>>"]}},{"Module":"EventListener","Tags":["EventListener","onEvent","supportsEventType","void","boolean","CodeEvent","String"],"Content":{"description":"Interface for classes that listen to and handle CodeEvents.  It defines methods for handling events and checking if an event listener supports a particular event type.","methods":[{"method":"onEvent","description":"Handles a received CodeEvent."},{"method":"supportsEventType","description":"Checks if the listener supports a given event type."}],"dependencies":["void","boolean","CodeEvent","String"]}},{"Module":"GeminiIntegrator","Tags":["GeminiIntegrator","processKnowledgeGraph","extractJsonFromResponse","void","RestTemplate","String","Logger","ObjectMapper"],"Content":{"description":"Integrates with the Gemini API to process knowledge graph content. It sends a request to the Gemini API, extracts JSON from the response, and saves the result.","methods":[{"method":"processKnowledgeGraph","description":"Sends the knowledge graph content to the Gemini API for processing and saves the JSON response."},{"method":"extractJsonFromResponse","description":"Extracts the JSON content from the Gemini API response."}],"dependencies":["void","RestTemplate","String","Logger","ObjectMapper"]}},{"Module":"GrokIntegrator","Tags":["GrokIntegrator","processKnowledgeGraph","extractJsonFromResponse","extractJsonFromMarkdown","void","RestTemplate","String","Logger","ObjectMapper"],"Content":{"description":"Integrates with the Grok API to process knowledge graph content. It sends a request containing the knowledge graph content and a prompt to the Grok API, handles the response, and saves the JSON result.","methods":[{"method":"processKnowledgeGraph","description":"Sends a request to the Grok API for processing and saves the JSON response."},{"method":"extractJsonFromResponse","description":"Extracts the JSON content from the Grok API response."},{"method":"extractJsonFromMarkdown","description":"Extracts JSON content from markdown text if present in the response."}],"dependencies":["void","RestTemplate","String","Logger","ObjectMapper"]}},{"Module":"CodeElement","Tags":["void","Set<String>","Map<String,String>","String","getId","setId","getType","setType","getName","setName","getDependencies","setDependencies","getMetadata","setMetadata","addDependency","getCodeBlock","setCodeBlock"],"Content":{"description":"public abstract class CodeElement","methods":[{"method":"getId","description":"public String getId() { return id; }"},{"method":"setId","description":"public void setId(String id) { this.id = id; }"},{"method":"getType","description":"public String getType() { return type; }"},{"method":"setType","description":"public void setType(String type) { this.type = type; }"},{"method":"getName","description":"public String getName() { return name; }"},{"method":"setName","description":"public void setName(String name) { this.name = name; }"},{"method":"getDependencies","description":"public Set<String> getDependencies() { return dependencies; }"},{"method":"setDependencies","description":"public void setDependencies(Set<String> dependencies) { this.dependencies = dependencies; }"},{"method":"getMetadata","description":"public Map<String, String> getMetadata() { return metadata; }"},{"method":"setMetadata","description":"public void setMetadata(Map<String, String> metadata) { this.metadata = metadata; }"},{"method":"addDependency","description":"public void addDependency(String dependency) {\n        if (dependency != null && !dependency.isEmpty()) {\n            this.dependencies.add(dependency);\n        }\n    }"},{"method":"getCodeBlock","description":"public String getCodeBlock() { \n        return codeBlock; \n    }"},{"method":"setCodeBlock","description":"public void setCodeBlock(String codeBlock) { \n        this.codeBlock = codeBlock; \n    }"}],"dependencies":["void","Set<String>","Map<String,String>","String"]}},{"Module":"FieldElement","Tags":["String","CodeElement","getType"],"Content":{"description":"public class FieldElement extends CodeElement","methods":[{"method":"getType","description":"public String getType() { return type; }"}],"dependencies":["String","CodeElement"]}},{"Module":"DependencyEdge","Tags":["void","DependencyNode","Map<String,Object>","Object","String","addProperty","getId","getSource","getTarget","getType","getProperties"],"Content":{"description":"public class DependencyEdge","methods":[{"method":"addProperty","description":"public void addProperty(String key, Object value) {\r\n        properties.put(key, value);\r\n    }"},{"method":"getId","description":"public String getId() { return id; }"},{"method":"getSource","description":"public DependencyNode getSource() { return source; }"},{"method":"getTarget","description":"public DependencyNode getTarget() { return target; }"},{"method":"getType","description":"public String getType() { return type; }"},{"method":"getProperties","description":"public Map<String, Object> getProperties() { return properties; }"}],"dependencies":["void","DependencyNode","Map<String,Object>","Object","String"]}},{"Module":"DependencyNode","Tags":["void","Set<DependencyEdge>","Map<String,Object>","Object","String","DependencyEdge","addOutgoingEdge","addIncomingEdge","addMetadata","getId","getName","getType","getOutgoingEdges","getIncomingEdges","getMetadata"],"Content":{"description":"public class DependencyNode","methods":[{"method":"addOutgoingEdge","description":"public void addOutgoingEdge(DependencyEdge edge) {\r\n        outgoingEdges.add(edge);\r\n    }"},{"method":"addIncomingEdge","description":"public void addIncomingEdge(DependencyEdge edge) {\r\n        incomingEdges.add(edge);\r\n    }"},{"method":"addMetadata","description":"public void addMetadata(String key, Object value) {\r\n        metadata.put(key, value);\r\n    }"},{"method":"getId","description":"public String getId() { return id; }"},{"method":"getName","description":"public String getName() { return name; }"},{"method":"getType","description":"public String getType() { return type; }"},{"method":"getOutgoingEdges","description":"public Set<DependencyEdge> getOutgoingEdges() { return outgoingEdges; }"},{"method":"getIncomingEdges","description":"public Set<DependencyEdge> getIncomingEdges() { return incomingEdges; }"},{"method":"getMetadata","description":"public Map<String, Object> getMetadata() { return metadata; }"}],"dependencies":["void","Set<DependencyEdge>","Map<String,Object>","Object","String","DependencyEdge"]}},{"Module":"MethodElement","Tags":["void","String","List<ParameterInfo>","CodeElement","addParameter","setReturnType","getReturnType","getParameters"],"Content":{"description":"public class MethodElement extends CodeElement","methods":[{"method":"addParameter","description":"public void addParameter(String type, String name) {\r\n        parameters.add(new ParameterInfo(type, name));\r\n        dependencies.add(type);\r\n    }"},{"method":"setReturnType","description":"public void setReturnType(String returnType) {\r\n        this.returnType = returnType;\r\n        dependencies.add(returnType);\r\n    }"},{"method":"getReturnType","description":"public String getReturnType() { return returnType; }"},{"method":"getParameters","description":"public List<ParameterInfo> getParameters() { return parameters; }"}],"dependencies":["void","String","List<ParameterInfo>","CodeElement"]}},{"Module":"ModuleInfo","Tags":["String","Set<String>","Map<String,String>","void"],"Content":{"description":"Module information.","methods":[{"method":"addExport","description":"Adds an export package name."},{"method":"addRequirement","description":"Adds a module requirement."},{"method":"setProperty","description":"Sets a property."},{"method":"getName","description":"Gets the module name."},{"method":"getVersion","description":"Gets the module version."},{"method":"getExports","description":"Gets the set of exported packages."},{"method":"getRequires","description":"Gets the set of required modules."},{"method":"getProperties","description":"Gets the module properties."}],"dependencies":["void","Set<String>","Map<String,String>","String"]}},{"Module":"ElementState","Tags":["void","boolean","Set<String>","String","Set<StateTransition>"],"Content":{"description":"Represents the state of an element.","methods":[{"method":"addAllowedTransition","description":"Adds an allowed state transition."},{"method":"canTransition","description":"Checks if a transition is allowed."},{"method":"getCurrentState","description":"Gets the current state."},{"method":"transition","description":"Performs a state transition."},{"method":"getTransitions","description":"Gets the set of state transitions."}],"dependencies":["void","boolean","Set<String>","String","Set<StateTransition>"]}},{"Module":"StateTransition","Tags":["String"],"Content":{"description":"Represents a state transition.","methods":[{"method":"getFromState","description":"Gets the source state."},{"method":"getToState","description":"Gets the target state."},{"method":"getCondition","description":"Gets the transition condition."}],"dependencies":["String"]}},{"Module":"CodeElementRepository","Tags":["Optional<CodeElement>","List<CodeElement>","String","CodeElement"],"Content":{"description":"Repository for code elements.","methods":[{"method":"save","description":"Saves a code element."},{"method":"findById","description":"Finds a code element by ID."},{"method":"findByName","description":"Finds code elements by name."},{"method":"findByType","description":"Finds code elements by type."},{"method":"findByDependency","description":"Finds code elements by dependency ID."}],"dependencies":["Optional<CodeElement>","List<CodeElement>","String","CodeElement"]}},{"Module":"InMemoryCodeElementRepository","Tags":["Optional<CodeElement>","List<CodeElement>","Map<String,CodeElement>","CodeElementRepository","String","CodeElement"],"Content":{"description":"In-memory implementation of CodeElementRepository.","methods":[{"method":"save","description":"Saves a code element."},{"method":"findById","description":"Finds a code element by ID."},{"method":"findByName","description":"Finds code elements by name."},{"method":"findByType","description":"Finds code elements by type."},{"method":"findByDependency","description":"Finds code elements by dependency ID."}],"dependencies":["Optional<CodeElement>","List<CodeElement>","Map<String,CodeElement>","CodeElementRepository","String","CodeElement"]}},{"Module":"AnalysisService","Tags":["void","String","Logger","JsonProcessor","GeminiIntegrator","CodebaseAnalysisLauncher","analyzeAndProcessCodebase"],"Content":{"description":"@Service\r\npublic class AnalysisService {\r\n    private static final Logger logger = LoggerFactory.getLogger(AnalysisService.class);\r\n    \r\n    private final CodebaseAnalysisLauncher launcher;\r\n    private final GeminiIntegrator geminiIntegrator;\r\n    private final JsonProcessor jsonProcessor;\r\n\r\n    @Autowired\r\n    public AnalysisService(\r\n            CodebaseAnalysisLauncher launcher, \r\n            GeminiIntegrator geminiIntegrator,\r\n            JsonProcessor jsonProcessor) {\r\n        this.launcher = launcher;\r\n        this.geminiIntegrator = geminiIntegrator;\r\n        this.jsonProcessor = jsonProcessor;\r\n    }\r\n\r\n    public void analyzeAndProcessCodebase(String basePath) {\r\n        try {\r\n            logger.info(\"Starting codebase analysis for path: {}\", basePath);\r\n            \r\n            // Generate knowledge graph\r\n            String knowledgeGraph = launcher.analyzeCodebase(basePath);\r\n            logger.info(\"Knowledge graph generated successfully\");\r\n\r\n            // First save the complete knowledge graph\r\n            KnowledgeGraphFileHandler.saveKnowledgeGraph(knowledgeGraph);\r\n            \r\n            // Process with JsonProcessor (which will handle splitting and API calls)\r\n            logger.info(\"Starting chunked JSON processing\");\r\n            jsonProcessor.processKnowledgeGraph(\"knowledge-graph.json\");\r\n            logger.info(\"Completed chunked JSON processing\");\r\n            \r\n        } catch (Exception e) {\r\n            logger.error(\"Failed to complete analysis and processing\", e);\r\n            throw new RuntimeException(\"Analysis and processing failed\", e);\r\n        }\r\n    }\r\n}","methods":[{"method":"analyzeAndProcessCodebase","description":"public void analyzeAndProcessCodebase(String basePath) {\r\n        try {\r\n            logger.info(\"Starting codebase analysis for path: {}\", basePath);\r\n            \r\n            // Generate knowledge graph\r\n            String knowledgeGraph = launcher.analyzeCodebase(basePath);\r\n            logger.info(\"Knowledge graph generated successfully\");\r\n\r\n            // First save the complete knowledge graph\r\n            KnowledgeGraphFileHandler.saveKnowledgeGraph(knowledgeGraph);\r\n            \r\n            // Process with JsonProcessor (which will handle splitting and API calls)\r\n            logger.info(\"Starting chunked JSON processing\");\r\n            jsonProcessor.processKnowledgeGraph(\"knowledge-graph.json\");\r\n            logger.info(\"Completed chunked JSON processing\");\r\n            \r\n        } catch (Exception e) {\r\n            logger.error(\"Failed to complete analysis and processing\", e);\r\n            throw new RuntimeException(\"Analysis and processing failed\", e);\r\n        }\r\n    }"}],"dependencies":["CodebaseAnalysisLauncher","void","String","Logger","JsonProcessor","GeminiIntegrator"]}},{"Module":"CodeDiscoveryService","Tags":["KafkaTemplate<String,String>","List<Map<String,String>>","Map<String,Object>","Set<CodeElement>","CodeElementRepository","String","processQuery","processLocalQuery","mapRelationships"],"Content":{"description":"@Service\npublic class CodeDiscoveryService {\n    private final KafkaTemplate<String, String> kafkaTemplate;\n    private final CodeElementRepository repository;\n\n    public CodeDiscoveryService(\n            KafkaTemplate<String, String> kafkaTemplate,\n            CodeElementRepository repository) {\n        this.kafkaTemplate = kafkaTemplate;\n        this.repository = repository;\n    }\n\n    public Map<String, Object> processQuery(String query) {\n        // Broadcast query to all nodes via Kafka\n        kafkaTemplate.send(\"code-discovery-queries\", query);\n\n        // Process query locally\n        Map<String, Object> results = processLocalQuery(query);\n        \n        // Add metadata about the query\n        results.put(\"query\", query);\n        return results;\n    }\n\n    private Map<String, Object> processLocalQuery(String query) {\n        Map<String, Object> response = new HashMap<>();\n        \n        if (query.startsWith(\"class:\")) {\n            String className = query.substring(6);\n            List<CodeElement> directElements = repository.findByName(className);\n            Set<CodeElement> relatedElements = new HashSet<>();\n            \n            // Find direct dependencies\n            for (CodeElement element : directElements) {\n                relatedElements.add(element);\n                // Add dependencies\n                for (String depId : element.getDependencies()) {\n                    repository.findById(depId).ifPresent(relatedElements::add);\n                }\n                // Add dependents\n                relatedElements.addAll(repository.findByDependency(element.getId()));\n            }\n            \n            response.put(\"directElements\", directElements);\n            response.put(\"relatedElements\", relatedElements);\n            response.put(\"relationships\", mapRelationships(relatedElements));\n            \n        } else if (query.startsWith(\"dependencies:\")) {\n            String elementName = query.substring(13);\n            List<CodeElement> elements = repository.findByName(elementName);\n            Set<String> allDependencies = new HashSet<>();\n            \n            for (CodeElement element : elements) {\n                allDependencies.addAll(element.getDependencies());\n            }\n            \n            List<CodeElement> dependencyElements = allDependencies.stream()\n                .map(repository::findById)\n                .filter(Optional::isPresent)\n                .map(Optional::get)\n                .collect(Collectors.toList());\n                \n            response.put(\"dependencies\", dependencyElements);\n            \n        } else if (query.startsWith(\"dependents:\")) {\n            String elementName = query.substring(11);\n            List<CodeElement> elements = repository.findByName(elementName);\n            Set<CodeElement> dependentElements = new HashSet<>();\n            \n            for (CodeElement element : elements) {\n                dependentElements.addAll(repository.findByDependency(element.getId()));\n            }\n            \n            response.put(\"dependents\", dependentElements);\n        }\n        \n        return response;\n    }\n\n    private List<Map<String, String>> mapRelationships(Set<CodeElement> elements) {\n        List<Map<String, String>> relationships = new ArrayList<>();\n        \n        for (CodeElement element : elements) {\n            for (String depId : element.getDependencies()) {\n                Map<String, String> relationship = new HashMap<>();\n                relationship.put(\"source\", element.getId());\n                relationship.put(\"target\", depId);\n                relationship.put(\"type\", \"DEPENDS_ON\");\n                relationships.add(relationship);\n            }\n        }\n        \n        return relationships;\n    }\n}","methods":[{"method":"processQuery","description":"public Map<String, Object> processQuery(String query) {\n        // Broadcast query to all nodes via Kafka\n        kafkaTemplate.send(\"code-discovery-queries\", query);\n\n        // Process query locally\n        Map<String, Object> results = processLocalQuery(query);\n        \n        // Add metadata about the query\n        results.put(\"query\", query);\n        return results;\n    }"},{"method":"processLocalQuery","description":"private Map<String, Object> processLocalQuery(String query) {\n        Map<String, Object> response = new HashMap<>();\n        \n        if (query.startsWith(\"class:\")) {\n            String className = query.substring(6);\n            List<CodeElement> directElements = repository.findByName(className);\n            Set<CodeElement> relatedElements = new HashSet<>();\n            \n            // Find direct dependencies\n            for (CodeElement element : directElements) {\n                relatedElements.add(element);\n                // Add dependencies\n                for (String depId : element.getDependencies()) {\n                    repository.findById(depId).ifPresent(relatedElements::add);\n                }\n                // Add dependents\n                relatedElements.addAll(repository.findByDependency(element.getId()));\n            }\n            \n            response.put(\"directElements\", directElements);\n            response.put(\"relatedElements\", relatedElements);\n            response.put(\"relationships\", mapRelationships(relatedElements));\n            \n        } else if (query.startsWith(\"dependencies:\")) {\n            String elementName = query.substring(13);\n            List<CodeElement> elements = repository.findByName(elementName);\n            Set<String> allDependencies = new HashSet<>();\n            \n            for (CodeElement element : elements) {\n                allDependencies.addAll(element.getDependencies());\n            }\n            \n            List<CodeElement> dependencyElements = allDependencies.stream()\n                .map(repository::findById)\n                .filter(Optional::isPresent)\n                .map(Optional::get)\n                .collect(Collectors.toList());\n                \n            response.put(\"dependencies\", dependencyElements);\n            \n        } else if (query.startsWith(\"dependents:\")) {\n            String elementName = query.substring(11);\n            List<CodeElement> elements = repository.findByName(elementName);\n            Set<CodeElement> dependentElements = new HashSet<>();\n            \n            for (CodeElement element : elements) {\n                dependentElements.addAll(repository.findByDependency(element.getId()));\n            }\n            \n            response.put(\"dependents\", dependentElements);\n        }\n        \n        return response;\n    }"},{"method":"mapRelationships","description":"private List<Map<String, String>> mapRelationships(Set<CodeElement> elements) {\n        List<Map<String, String>> relationships = new ArrayList<>();\n        \n        for (CodeElement element : elements) {\n            for (String depId : element.getDependencies()) {\n                Map<String, String> relationship = new HashMap<>();\n                relationship.put(\"source\", element.getId());\n                relationship.put(\"target\", depId);\n                relationship.put(\"type\", \"DEPENDS_ON\");\n                relationships.add(relationship);\n            }\n        }\n        \n        return relationships;\n    }"}],"dependencies":["KafkaTemplate<String,String>","List<Map<String,String>>","Map<String,Object>","Set<CodeElement>","CodeElementRepository","String"]}},{"Module":"State","Tags":["void","Map<String,String>","StateTransition","String","Set<StateTransition>","addTransition","addMetadata","getName","getMetadata","getTransitions"],"Content":{"description":"public class State {\r\n    private String name;\r\n    private Map<String, String> metadata;\r\n    private Set<StateTransition> transitions;\r\n\r\n    public State(String name) {\r\n        this.name = name;\r\n        this.metadata = new HashMap<>();\r\n        this.transitions = new HashSet<>();\r\n    }\r\n\r\n    public void addTransition(StateTransition transition) {\r\n        transitions.add(transition);\r\n    }\r\n\r\n    public void addMetadata(String key, String value) {\r\n        metadata.put(key, value);\r\n    }\r\n\r\n    public String getName() { return name; }\r\n    public Map<String, String> getMetadata() { return metadata; }\r\n    public Set<StateTransition> getTransitions() { return transitions; }\r\n}","methods":[{"method":"addTransition","description":"public void addTransition(StateTransition transition) {\r\n        transitions.add(transition);\r\n    }"},{"method":"addMetadata","description":"public void addMetadata(String key, String value) {\r\n        metadata.put(key, value);\r\n    }"},{"method":"getName","description":"public String getName() { return name; }"},{"method":"getMetadata","description":"public Map<String, String> getMetadata() { return metadata; }"},{"method":"getTransitions","description":"public Set<StateTransition> getTransitions() { return transitions; }"}],"dependencies":["void","Map<String,String>","StateTransition","String","Set<StateTransition>"]}},{"Module":"StateMachine","Tags":["boolean","void","Map<String,State>","State","Map<String,Object>","Map<String,Map<String,State>>","String","Logger","getStates","canTransition","addState","getCurrentState"],"Content":{"description":"@Component\r\npublic class StateMachine {\r\n    private static final Logger logger = LoggerFactory.getLogger(StateMachine.class);\r\n    private Map<String, Map<String, State>> classStates = new HashMap<>();\r\n    private Map<String, State> currentStates = new HashMap<>();\r\n\r\n    public Map<String, Object> getStates(String className) {\r\n        logger.info(\"Getting states for class: {}\", className);\r\n        Map<String, Object> states = new HashMap<>();\r\n        \r\n        if (classStates.containsKey(className)) {\r\n            Map<String, State> stateMap = classStates.get(className);\r\n            \r\n            // Convert states to a more friendly format\r\n            List<Map<String, Object>> stateList = new ArrayList<>();\r\n            stateMap.forEach((stateName, state) -> {\r\n                Map<String, Object> stateInfo = new HashMap<>();\r\n                stateInfo.put(\"name\", stateName);\r\n                stateInfo.put(\"metadata\", state.getMetadata());\r\n                \r\n                // Convert transitions to a list\r\n                List<Map<String, String>> transitions = new ArrayList<>();\r\n                state.getTransitions().forEach(transition -> {\r\n                    Map<String, String> transInfo = new HashMap<>();\r\n                    transInfo.put(\"to\", transition.getToState().getName());\r\n                    transInfo.put(\"condition\", transition.getCondition());\r\n                    transitions.add(transInfo);\r\n                });\r\n                stateInfo.put(\"transitions\", transitions);\r\n                \r\n                stateList.add(stateInfo);\r\n            });\r\n            \r\n            states.put(\"states\", stateList);\r\n            State currentState = currentStates.get(className);\r\n            states.put(\"currentState\", currentState != null ? currentState.getName() : null);\r\n        }\r\n        \r\n        return states;\r\n    }\r\n\r\n    public boolean canTransition(String className, String fromStateName, String toStateName) {\r\n        logger.info(\"Checking transition from {} to {} for class {}\", fromStateName, toStateName, className);\r\n        \r\n        Map<String, State> stateMap = classStates.get(className);\r\n        if (stateMap == null) {\r\n            return false;\r\n        }\r\n\r\n        State fromState = stateMap.get(fromStateName);\r\n        State toState = stateMap.get(toStateName);\r\n        \r\n        if (fromState == null || toState == null) {\r\n            return false;\r\n        }\r\n\r\n        return fromState.getTransitions().stream()\r\n            .anyMatch(transition -> \r\n                transition.getToState().getName().equals(toStateName));\r\n    }\r\n\r\n    public void addState(String className, State state) {\r\n        classStates.computeIfAbsent(className, k -> new HashMap<>())\r\n                  .put(state.getName(), state);\r\n                  \r\n        // If this is the first state for this class, set it as current\r\n        if (!currentStates.containsKey(className)) {\r\n            currentStates.put(className, state);\r\n        }\r\n    }\r\n\r\n    public State getCurrentState(String className) {\r\n        return currentStates.get(className);\r\n    }\r\n}","methods":[{"method":"getStates","description":"public Map<String, Object> getStates(String className) {\r\n        logger.info(\"Getting states for class: {}\", className);\r\n        Map<String, Object> states = new HashMap<>();\r\n        \r\n        if (classStates.containsKey(className)) {\r\n            Map<String, State> stateMap = classStates.get(className);\r\n            \r\n            // Convert states to a more friendly format\r\n            List<Map<String, Object>> stateList = new ArrayList<>();\r\n            stateMap.forEach((stateName, state) -> {\r\n                Map<String, Object> stateInfo = new HashMap<>();\r\n                stateInfo.put(\"name\", stateName);\r\n                stateInfo.put(\"metadata\", state.getMetadata());\r\n                \r\n                // Convert transitions to a list\r\n                List<Map<String, String>> transitions = new ArrayList<>();\r\n                state.getTransitions().forEach(transition -> {\r\n                    Map<String, String> transInfo = new HashMap<>();\r\n                    transInfo.put(\"to\", transition.getToState().getName());\r\n                    transInfo.put(\"condition\", transition.getCondition());\r\n                    transitions.add(transInfo);\r\n                });\r\n                stateInfo.put(\"transitions\", transitions);\r\n                \r\n                stateList.add(stateInfo);\r\n            });\r\n            \r\n            states.put(\"states\", stateList);\r\n            State currentState = currentStates.get(className);\r\n            states.put(\"currentState\", currentState != null ? currentState.getName() : null);\r\n        }\r\n        \r\n        return states;\r\n    }"},{"method":"canTransition","description":"public boolean canTransition(String className, String fromStateName, String toStateName) {\r\n        logger.info(\"Checking transition from {} to {} for class {}\", fromStateName, toStateName, className);\r\n        \r\n        Map<String, State> stateMap = classStates.get(className);\r\n        if (stateMap == null) {\r\n            return false;\r\n        }\r\n\r\n        State fromState = stateMap.get(fromStateName);\r\n        State toState = stateMap.get(toStateName);\r\n        \r\n        if (fromState == null || toState == null) {\r\n            return false;\r\n        }\r\n\r\n        return fromState.getTransitions().stream()\r\n            .anyMatch(transition -> \r\n                transition.getToState().getName().equals(toStateName));\r\n    }"},{"method":"addState","description":"public void addState(String className, State state) {\r\n        classStates.computeIfAbsent(className, k -> new HashMap<>())\r\n                  .put(state.getName(), state);\r\n                  \r\n        // If this is the first state for this class, set it as current\r\n        if (!currentStates.containsKey(className)) {\r\n            currentStates.put(className, state);\r\n        }\r\n    }"},{"method":"getCurrentState","description":"public State getCurrentState(String className) {\r\n        return currentStates.get(className);\r\n    }"}],"dependencies":["boolean","void","Map<String,State>","State","Map<String,Object>","Map<String,Map<String,State>>","String","Logger"]}},{"Module":"StateTransition","Tags":["void","State","String","setAction","getFromState","getToState","getCondition","getAction"],"Content":{"description":"public class StateTransition {\r\n    private State fromState;\r\n    private State toState;\r\n    private String condition;\r\n    private String action;\r\n\r\n    public StateTransition(State fromState, State toState, String condition) {\r\n        this.fromState = fromState;\r\n        this.toState = toState;\r\n        this.condition = condition;\r\n    }\r\n\r\n    public void setAction(String action) {\r\n        this.action = action;\r\n    }\r\n\r\n    public State getFromState() { return fromState; }\r\n    public State getToState() { return toState; }\r\n    public String getCondition() { return condition; }\r\n    public String getAction() { return action; }\r\n}","methods":[{"method":"setAction","description":"public void setAction(String action) {\r\n        this.action = action;\r\n    }"},{"method":"getFromState","description":"public State getFromState() { return fromState; }"},{"method":"getToState","description":"public State getToState() { return toState; }"},{"method":"getCondition","description":"public String getCondition() { return condition; }"},{"method":"getAction","description":"public String getAction() { return action; }"}],"dependencies":["void","State","String"]}},{"Module":"TestService","Tags":["void","LoggingService","DatabaseService"],"Content":{"description":"@Service\npublic class TestService {\n    private final DatabaseService databaseService;\n    private final LoggingService loggingService;\n\n    public TestService(DatabaseService databaseService, LoggingService loggingService) {\n        this.databaseService = databaseService;\n        this.loggingService = loggingService;\n    }\n\n    public void processData() {\n        loggingService.log(\"Starting data processing\");\n        String data = databaseService.getData();\n        data = data.toLowerCase();\n        databaseService.saveData(data);\n        loggingService.log(\"Data processing complete\");\n    }\n}","methods":[{"method":"processData","description":"public void processData() {\n        loggingService.log(\"Starting data processing\");\n        String data = databaseService.getData();\n        data = data.toLowerCase();\n        databaseService.saveData(data);\n        loggingService.log(\"Data processing complete\");\n    }"}],"dependencies":["void","LoggingService","DatabaseService"]}},{"Module":"TestServiceRunner","Tags":["void","TestService","CommandLineRunner","String","OrderService"],"Content":{"description":"@Component\r\npublic class TestServiceRunner implements CommandLineRunner {\r\n    private final TestService testService;\r\n    private final OrderService orderService; // Advanced test functionality\r\n\r\n    public TestServiceRunner(TestService testService, OrderService orderService) {\r\n        this.testService = testService;\r\n        this.orderService = orderService;\r\n    }\r\n\r\n    @Override\r\n    public void run(String... args) {\r\n        System.out.println(\"Running basic test:\");\r\n        testService.processData();\r\n\r\n        System.out.println(\"Running advanced tests:\");\r\n        orderService.processOrder(\"ORDER123\");\r\n        orderService.processOrder(\"ORDER456\");\r\n    }\r\n}","methods":[{"method":"run","description":"@Override\r\n    public void run(String... args) {\r\n        System.out.println(\"Running basic test:\");\r\n        testService.processData();\r\n\r\n        System.out.println(\"Running advanced tests:\");\r\n        orderService.processOrder(\"ORDER123\");\r\n        orderService.processOrder(\"ORDER456\");\r\n    }"}],"dependencies":["void","TestService","CommandLineRunner","String","OrderService"]}},{"Module":"KnowledgeGraphFileHandler","Tags":["void","String","Logger"],"Content":{"description":"@Component\r\npublic class KnowledgeGraphFileHandler {\r\n    private static final Logger logger = LoggerFactory.getLogger(KnowledgeGraphFileHandler.class);\r\n    private static final String KNOWLEDGE_GRAPH_FILENAME = \"knowledge-graph.json\";\r\n    private static final String DESCRIPTIONS_FILENAME = \"knowledge-graph-descriptions.json\";\r\n\r\n    public static void saveKnowledgeGraph(String content) {\r\n        try {\r\n            // Ensure content is not null or empty\r\n            if (content == null || content.trim().isEmpty()) {\r\n                throw new IllegalArgumentException(\"Content cannot be null or empty\");\r\n            }\r\n\r\n            // Get the current working directory\r\n            Path currentPath = Paths.get(\"\").toAbsolutePath();\r\n            Path outputPath = currentPath.resolve(KNOWLEDGE_GRAPH_FILENAME);\r\n\r\n            // Create directories if they don't exist\r\n            Files.createDirectories(outputPath.getParent());\r\n\r\n            // Write the file with proper options\r\n            Files.writeString(\r\n                outputPath,\r\n                content,\r\n                StandardOpenOption.CREATE,\r\n                StandardOpenOption.TRUNCATE_EXISTING\r\n            );\r\n\r\n            logger.info(\"Knowledge graph saved successfully to: {}\", outputPath);\r\n\r\n        } catch (IOException e) {\r\n            logger.error(\"Failed to save knowledge graph\", e);\r\n            throw new RuntimeException(\"Failed to save knowledge graph\", e);\r\n        } catch (IllegalArgumentException e) {\r\n            logger.error(\"Invalid content provided\", e);\r\n            throw new RuntimeException(\"Invalid content provided for knowledge graph\", e);\r\n        }\r\n    }\r\n\r\n    public static void saveKnowledgeGraphDescriptions(String content) {\r\n        try {\r\n            // Ensure content is not null or empty\r\n            if (content == null || content.trim().isEmpty()) {\r\n                throw new IllegalArgumentException(\"Content cannot be null or empty\");\r\n            }\r\n\r\n            // Get the current working directory\r\n            Path currentPath = Paths.get(\"\").toAbsolutePath();\r\n            Path outputPath = currentPath.resolve(DESCRIPTIONS_FILENAME);\r\n\r\n            // Create directories if they don't exist\r\n            Files.createDirectories(outputPath.getParent());\r\n\r\n            // Write the file with proper options\r\n            Files.writeString(\r\n                outputPath,\r\n                content,\r\n                StandardOpenOption.CREATE,\r\n                StandardOpenOption.TRUNCATE_EXISTING\r\n            );\r\n\r\n            logger.info(\"Knowledge graph descriptions saved successfully to: {}\", outputPath);\r\n\r\n        } catch (IOException e) {\r\n            logger.error(\"Failed to save knowledge graph descriptions\", e);\r\n            throw new RuntimeException(\"Failed to save knowledge graph descriptions\", e);\r\n        } catch (IllegalArgumentException e) {\r\n            logger.error(\"Invalid content provided\", e);\r\n            throw new RuntimeException(\"Invalid content provided for knowledge graph descriptions\", e);\r\n        }\r\n    }\r\n\r\n    public static String readKnowledgeGraph() {\r\n        try {\r\n            Path currentPath = Paths.get(\"\").toAbsolutePath();\r\n            Path inputPath = currentPath.resolve(KNOWLEDGE_GRAPH_FILENAME);\r\n            \r\n            if (!Files.exists(inputPath)) {\r\n                throw new IOException(\"knowledge-graph.json not found at: \" + inputPath);\r\n            }\r\n\r\n            return Files.readString(inputPath);\r\n        } catch (IOException e) {\r\n            logger.error(\"Failed to read knowledge graph file\", e);\r\n            throw new RuntimeException(\"Failed to read knowledge graph file\", e);\r\n        }\r\n    }\r\n}","methods":[{"method":"saveKnowledgeGraph","description":"public static void saveKnowledgeGraph(String content) {\r\n        try {\r\n            // Ensure content is not null or empty\r\n            if (content == null || content.trim().isEmpty()) {\r\n                throw new IllegalArgumentException(\"Content cannot be null or empty\");\r\n            }\r\n\r\n            // Get the current working directory\r\n            Path currentPath = Paths.get(\"\").toAbsolutePath();\r\n            Path outputPath = currentPath.resolve(KNOWLEDGE_GRAPH_FILENAME);\r\n\r\n            // Create directories if they don't exist\r\n            Files.createDirectories(outputPath.getParent());\r\n\r\n            // Write the file with proper options\r\n            Files.writeString(\r\n                outputPath,\r\n                content,\r\n                StandardOpenOption.CREATE,\r\n                StandardOpenOption.TRUNCATE_EXISTING\r\n            );\r\n\r\n            logger.info(\"Knowledge graph saved successfully to: {}\", outputPath);\r\n\r\n        } catch (IOException e) {\r\n            logger.error(\"Failed to save knowledge graph\", e);\r\n            throw new RuntimeException(\"Failed to save knowledge graph\", e);\r\n        } catch (IllegalArgumentException e) {\r\n            logger.error(\"Invalid content provided\", e);\r\n            throw new RuntimeException(\"Invalid content provided for knowledge graph\", e);\r\n        }\r\n    }"},{"method":"saveKnowledgeGraphDescriptions","description":"public static void saveKnowledgeGraphDescriptions(String content) {\r\n        try {\r\n            // Ensure content is not null or empty\r\n            if (content == null || content.trim().isEmpty()) {\r\n                throw new IllegalArgumentException(\"Content cannot be null or empty\");\r\n            }\r\n\r\n            // Get the current working directory\r\n            Path currentPath = Paths.get(\"\").toAbsolutePath();\r\n            Path outputPath = currentPath.resolve(DESCRIPTIONS_FILENAME);\r\n\r\n            // Create directories if they don't exist\r\n            Files.createDirectories(outputPath.getParent());\r\n\r\n            // Write the file with proper options\r\n            Files.writeString(\r\n                outputPath,\r\n                content,\r\n                StandardOpenOption.CREATE,\r\n                StandardOpenOption.TRUNCATE_EXISTING\r\n            );\r\n\r\n            logger.info(\"Knowledge graph descriptions saved successfully to: {}\", outputPath);\r\n\r\n        } catch (IOException e) {\r\n            logger.error(\"Failed to save knowledge graph descriptions\", e);\r\n            throw new RuntimeException(\"Failed to save knowledge graph descriptions\", e);\r\n        } catch (IllegalArgumentException e) {\r\n            logger.error(\"Invalid content provided\", e);\r\n            throw new RuntimeException(\"Invalid content provided for knowledge graph descriptions\", e);\r\n        }\r\n    }"},{"method":"readKnowledgeGraph","description":"public static String readKnowledgeGraph() {\r\n        try {\r\n            Path currentPath = Paths.get(\"\").toAbsolutePath();\r\n            Path inputPath = currentPath.resolve(KNOWLEDGE_GRAPH_FILENAME);\r\n            \r\n            if (!Files.exists(inputPath)) {\r\n                throw new IOException(\"knowledge-graph.json not found at: \" + inputPath);\r\n            }\r\n\r\n            return Files.readString(inputPath);\r\n        } catch (IOException e) {\r\n            logger.error(\"Failed to read knowledge graph file\", e);\r\n            throw new RuntimeException(\"Failed to read knowledge graph file\", e);\r\n        }\r\n    }"}],"dependencies":["void","String","Logger"]}},{"Module":"OrderProcessor","Tags":["void","String"],"Content":{"description":"public class OrderProcessor {\r\n    private String currentState = \"NEW\";\r\n    \r\n    public void processOrder() {\r\n        if (currentState.equals(\"NEW\")) {\r\n            validateOrder();\r\n            currentState = \"VALIDATED\";\r\n        }\r\n        \r\n        if (currentState.equals(\"VALIDATED\")) {\r\n            processPayment();\r\n            currentState = \"PAID\";\r\n        }\r\n        \r\n        if (currentState.equals(\"PAID\")) {\r\n            shipOrder();\r\n            currentState = \"SHIPPED\";\r\n        }\r\n    }\r\n    \r\n    private void validateOrder() { /* validation logic */ }\r\n    private void processPayment() { /* payment logic */ }\r\n    private void shipOrder() { /* shipping logic */ }\r\n}","methods":[{"method":"processOrder","description":"public void processOrder() {\r\n        if (currentState.equals(\"NEW\")) {\r\n            validateOrder();\r\n            currentState = \"VALIDATED\";\r\n        }\r\n        \r\n        if (currentState.equals(\"VALIDATED\")) {\r\n            processPayment();\r\n            currentState = \"PAID\";\r\n        }\r\n        \r\n        if (currentState.equals(\"PAID\")) {\r\n            shipOrder();\r\n            currentState = \"SHIPPED\";\r\n        }\r\n    }"},{"method":"validateOrder","description":"private void validateOrder() { /* validation logic */ }"},{"method":"processPayment","description":"private void processPayment() { /* payment logic */ }"},{"method":"shipOrder","description":"private void shipOrder() { /* shipping logic */ }"}],"dependencies":["void","String"]}},{"Module":"TestCase1","Tags":["void","String","int"],"Content":{"description":"public class TestCase1 {\r\n    private int counter = 0;\r\n    private String message;\r\n\r\n    public void processData(String input) {\r\n        try {\r\n            if (input == null) {\r\n                throw new IllegalArgumentException(\"Input cannot be null\");\r\n            }\r\n            \r\n            for (int i = 0; i < input.length(); i++) {\r\n                counter++;\r\n                if (Character.isDigit(input.charAt(i))) {\r\n                    message = \"Found digit at position \" + i;\r\n                    break;\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            message = \"Error: \" + e.getMessage();\r\n        }\r\n    }\r\n}","methods":[{"method":"processData","description":"public void processData(String input) {\r\n        try {\r\n            if (input == null) {\r\n                throw new IllegalArgumentException(\"Input cannot be null\");\r\n            }\r\n            \r\n            for (int i = 0; i < input.length(); i++) {\r\n                counter++;\r\n                if (Character.isDigit(input.charAt(i))) {\r\n                    message = \"Found digit at position \" + i;\r\n                    break;\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            message = \"Error: \" + e.getMessage();\r\n        }\r\n    }"}],"dependencies":["void","String","int"]}},{"Module":"OrderProcessor","Tags":["void","String"],"Content":{"description":"OrderProcessor class","methods":[{"method":"processOrder","description":"processOrder method"},{"method":"validateOrder","description":"validateOrder method"},{"method":"processPayment","description":"processPayment method"},{"method":"shipOrder","description":"shipOrder method"}],"dependencies":["void","String"]}},{"Module":"TestCase1","Tags":["void","String","int"],"Content":{"description":"TestCase1 class","methods":[{"method":"processData","description":"processData method"}],"dependencies":["void","String","int"]}}]